import { useCallback, useState } from 'react';
import { useWallet } from '@/lib/providers/WalletProvider';
import { useWeb3Store } from '@/lib/stores/web3Store';
import { CONTRACT_ADDRESSES, GAS_CONFIG } from '@/lib/contracts/config';
import NFT_MANAGER_ABI_DATA from '@/lib/contracts/nft-manager-abi.json';
import NODE_NFT_ABI_DATA from '@/lib/contracts/node-nft-abi.json';
import USDT_ABI_DATA from '@/lib/contracts/usdt-abi.json';

const ABI = NFT_MANAGER_ABI_DATA.abi;
const NODE_NFT_ABI = NODE_NFT_ABI_DATA.abi;
const USDT_ABI = USDT_ABI_DATA.abi;

export interface SellOrder {
  orderId: number;
  nftId: number;
  seller: string;
  shares: number;
  pricePerShare: bigint;
  createdAt: number;
  active: boolean;
}

export interface SellOrderWithDetails extends SellOrder {
  totalPrice: bigint;
  sellerDisplay: string;
  createdAtDisplay: string;
}

/**
 * Hook to get sell orders for a specific NFT
 */
export function useNFTSellOrders(nftId: number) {
  const { walletManager } = useWallet();
  const [orders, setOrders] = useState<SellOrderWithDetails[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastFetchTime, setLastFetchTime] = useState<number>(0);

  const fetchOrders = useCallback(async () => {
    if (!walletManager || !nftId || nftId <= 0) {
      setOrders([]);
      return;
    }

    // Prevent too frequent calls (debounce)
    const now = Date.now();
    if (now - lastFetchTime < 2000) { // 2 seconds debounce
      console.log('‚è≥ Request too frequent, skipping this query');
      return;
    }
    setLastFetchTime(now);

    setIsLoading(true);
    setError(null);

    try {
      console.log('üîç Querying NFT sell orders...', { nftId, nftIdType: typeof nftId });

      // Validate contract address
      if (!CONTRACT_ADDRESSES.nftManager) {
        console.error('‚ùå NFT Manager contract address not configured');
        setError('NFT Manager contract address not configured, please check environment variables');
        setOrders([]);
        return;
      }

      // Validate NFT ID
      if (typeof nftId !== 'number' || nftId <= 0) {
        console.warn('‚ö†Ô∏è Invalid NFT ID:', nftId);
        setOrders([]);
        return;
      }

      // Get order IDs for this NFT
      const nftIdParam = Number(nftId);
      console.log(`üìã Call parameters:`, { nftIdParam, originalId: nftId });
      
      let orderIds: bigint[];
      try {
        orderIds = await walletManager.readContract(
          CONTRACT_ADDRESSES.nftManager,
          ABI as unknown[],
          'getNFTSellOrders',
          [nftIdParam]
        ) as bigint[];
      } catch (contractError) {
        console.error(`‚ùå Contract call failed (NFT ${nftIdParam}):`, contractError);
        throw new Error(`Failed to query NFT ${nftIdParam} orders: ${contractError}`);
      }

      console.log('üìã Found order IDs:', orderIds ? orderIds.map(id => id.toString()) : 'No orders');

      if (!orderIds || orderIds.length === 0) {
        setOrders([]);
        return;
      }

      // Fetch details for each order
      const orderPromises = orderIds.map(async (orderId) => {
        const orderData = await walletManager.readContract(
          CONTRACT_ADDRESSES.nftManager,
          ABI as unknown[],
          'sellOrders',
          [orderId]
        ) as [bigint, string, bigint, bigint, bigint, boolean];

        const [nftIdFromContract, seller, shares, pricePerShare, createdAt, active] = orderData;

        return {
          orderId: Number(orderId),
          nftId: Number(nftIdFromContract),
          seller,
          shares: Number(shares),
          pricePerShare,
          createdAt: Number(createdAt),
          active,
          totalPrice: shares * pricePerShare,
          sellerDisplay: formatAddress(seller),
          createdAtDisplay: formatDate(Number(createdAt))
        } as SellOrderWithDetails;
      });

      const orderDetails = await Promise.all(orderPromises);
      
      // Filter only active orders
      const activeOrders = orderDetails.filter(order => order.active);
      
      console.log('‚úÖ Ëé∑ÂèñÂà∞Ê¥ªË∑ÉËÆ¢Âçï:', activeOrders.length);
      setOrders(activeOrders);

    } catch (err) {
      console.error('‚ùå Êü•ËØ¢ËÆ¢ÂçïÂ§±Ë¥•:', err);
      setError(err instanceof Error ? err.message : 'Êü•ËØ¢ËÆ¢ÂçïÂ§±Ë¥•');
      setOrders([]);
    } finally {
      setIsLoading(false);
    }
  }, [walletManager, nftId]);

  return {
    data: orders,
    isLoading,
    error,
    refetch: fetchOrders
  };
}

/**
 * Hook to get all sell orders across all NFTs
 */
export function useAllSellOrders() {
  const { walletManager } = useWallet();
  const web3Store = useWeb3Store();
  const [orders, setOrders] = useState<SellOrderWithDetails[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastFetchTime, setLastFetchTime] = useState<number>(0);

  const fetchAllOrders = useCallback(async () => {
    if (!walletManager) {
      setOrders([]);
      return;
    }

    // Prevent too frequent calls (debounce)
    const now = Date.now();
    if (now - lastFetchTime < 2000) { // 2 seconds debounce
      console.log('‚è≥ Request too frequent, skipping this query');
      return;
    }
    setLastFetchTime(now);

    setIsLoading(true);
    setError(null);

    try {
      console.log('üîç Êü•ËØ¢ÊâÄÊúâÂá∫ÂîÆËÆ¢Âçï...');
      
      // Validate contract address
      if (!CONTRACT_ADDRESSES.nftManager) {
        console.error('‚ùå NFT Manager contract address not configured');
        console.error('‚ùå ËØ∑Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáè NEXT_PUBLIC_NFT_MANAGER_ADDRESS');
        setError('NFT Manager contract address not configured, please check environment variables');
        setOrders([]);
        return;
      }
      console.log('üìã NFT ManagerÂú∞ÂùÄ:', CONTRACT_ADDRESSES.nftManager);

      // Get NFTs from web3Store - wait for data to be loaded
      if (!web3Store.nfts || web3Store.nfts.length === 0) {
        console.log('üìã Web3Store‰∏≠ÊöÇÊó†NFTÊï∞ÊçÆÔºåÁ≠âÂæÖÊï∞ÊçÆÂä†ËΩΩ...');
        // Wait a bit for web3Store to load
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Check again after waiting
        if (!web3Store.nfts || web3Store.nfts.length === 0) {
          console.log('üìã Á≠âÂæÖÂêé‰ªçÊó†NFTÊï∞ÊçÆÔºåËøîÂõûÁ©∫ËÆ¢ÂçïÂàóË°®');
          setOrders([]);
          return;
        }
      }

      const nfts = web3Store.nfts || [];
      console.log('üìã ‰ªéweb3StoreËé∑ÂèñÂà∞NFTÊï∞Èáè:', nfts.length);
      console.log('üìã NFTÊï∞ÊçÆËØ¶ÊÉÖ:', nfts.map(nft => ({ id: nft.id, type: typeof nft.id })));

      if (nfts.length === 0) {
        console.log('üìã Ê≤°ÊúâÊâæÂà∞NFTÔºåËøîÂõûÁ©∫ËÆ¢ÂçïÂàóË°®');
        setOrders([]);
        return;
      }

      const allOrderPromises = nfts.map(async (nft: any) => {
        try {
          // Validate NFT data
          if (!nft) {
            console.warn(`‚ö†Ô∏è NFTÂØπË±°‰∏∫Á©∫`);
            return [];
          }
          
          if (typeof nft.id !== 'number' || nft.id <= 0) {
            console.warn(`‚ö†Ô∏è Êó†ÊïàÁöÑNFT ID:`, { 
              id: nft.id, 
              type: typeof nft.id, 
              nft: nft 
            });
            return [];
          }
          
          console.log(`üîç Êü•ËØ¢NFT ${nft.id} ÁöÑËÆ¢Âçï...`);
          
          // Use the NFT ID from web3Store
          const nftIdParam = Number(nft.id);
          console.log(`üìã Ë∞ÉÁî®ÂèÇÊï∞:`, { nftIdParam, originalId: nft.id });
          
          let orderIds: bigint[];
          try {
            console.log(`üìã ÂáÜÂ§áË∞ÉÁî®ÂêàÁ∫¶:`, {
              contractAddress: CONTRACT_ADDRESSES.nftManager,
              functionName: 'getNFTSellOrders',
              params: [nftIdParam],
              abiLength: ABI.length
            });
            
            orderIds = await walletManager.readContract(
              CONTRACT_ADDRESSES.nftManager,
              ABI as unknown[],
              'getNFTSellOrders',
              [nftIdParam]
            ) as bigint[];
          } catch (contractError) {
            console.error(`‚ùå Contract call failed (NFT ${nftIdParam}):`, contractError);
            console.error(`‚ùå ÈîôËØØËØ¶ÊÉÖ:`, {
              contractAddress: CONTRACT_ADDRESSES.nftManager,
              functionName: 'getNFTSellOrders',
              params: [nftIdParam],
              error: contractError
            });
            throw new Error(`Failed to query NFT ${nftIdParam} orders: ${contractError}`);
          }

          console.log(`üìã NFT ${nft.id} ËÆ¢ÂçïID:`, orderIds ? orderIds.map(id => id.toString()) : 'Êó†ËÆ¢Âçï');

          if (!orderIds || orderIds.length === 0) {
            console.log(`üìã NFT ${nft.id} Ê≤°ÊúâËÆ¢Âçï`);
            return [];
          }

          const orderDetails = await Promise.all(
            orderIds.map(async (orderId) => {
              try {
                const orderData = await walletManager.readContract(
                  CONTRACT_ADDRESSES.nftManager,
                  ABI as unknown[],
                  'sellOrders',
                  [orderId]
                ) as [bigint, string, bigint, bigint, bigint, boolean];

                const [nftIdFromContract, seller, shares, pricePerShare, createdAt, active] = orderData;

                return {
                  orderId: Number(orderId),
                  nftId: Number(nftIdFromContract),
                  seller,
                  shares: Number(shares),
                  pricePerShare,
                  createdAt: Number(createdAt),
                  active,
                  totalPrice: shares * pricePerShare,
                  sellerDisplay: formatAddress(seller),
                  createdAtDisplay: formatDate(Number(createdAt))
                } as SellOrderWithDetails;
              } catch (orderErr) {
                console.warn(`Êü•ËØ¢ËÆ¢Âçï ${orderId} ËØ¶ÊÉÖÂ§±Ë¥•:`, orderErr);
                return null;
              }
            })
          );

          const validOrders = orderDetails.filter(order => order !== null && order.active);
          console.log(`‚úÖ NFT ${nft.id} ÊâæÂà∞ ${validOrders.length} ‰∏™Ê¥ªË∑ÉËÆ¢Âçï`);
          return validOrders;
        } catch (err) {
          console.warn(`Êü•ËØ¢NFT ${nft.id} ËÆ¢ÂçïÂ§±Ë¥•:`, err);
          return [];
        }
      });

      const allOrders = await Promise.all(allOrderPromises);
      const flatOrders = allOrders.flat();
      
      console.log('‚úÖ Ëé∑ÂèñÂà∞ÊâÄÊúâÊ¥ªË∑ÉËÆ¢Âçï:', flatOrders.length);
      setOrders(flatOrders);

    } catch (err) {
      console.error('‚ùå Êü•ËØ¢ÊâÄÊúâËÆ¢ÂçïÂ§±Ë¥•:', err);
      setError(err instanceof Error ? err.message : 'Êü•ËØ¢ËÆ¢ÂçïÂ§±Ë¥•');
      setOrders([]);
    } finally {
      setIsLoading(false);
    }
  }, [walletManager, web3Store.nfts]);

  return {
    data: orders,
    isLoading,
    error,
    refetch: fetchAllOrders
  };
}

/**
 * Hook to cancel a sell order
 */
export function useCancelSellOrder() {
  const { address, walletManager } = useWallet();
  const web3Store = useWeb3Store();
  const [isLoading, setIsLoading] = useState(false);

  const cancelOrder = useCallback(async (params: { orderId: number }) => {
    if (!address || !walletManager) {
      throw new Error('Wallet not connected');
    }

    setIsLoading(true);
    try {
      console.log('üóëÔ∏è ÂèñÊ∂àÂá∫ÂîÆËÆ¢Âçï...');
      console.log('üìã ËÆ¢ÂçïID:', params.orderId);

      const txHash = await walletManager.writeContract(
        CONTRACT_ADDRESSES.nftManager,
        ABI as unknown[],
        'cancelSellOrder',
        [params.orderId],
        {
          gas: GAS_CONFIG.gasLimits.contractCall,
        }
      );

      console.log('‚úÖ ÂèñÊ∂àËÆ¢Âçï‰∫§ÊòìÂìàÂ∏å:', txHash);
      console.log('‚è≥ Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§...');

      const receipt = await walletManager.waitForTransaction(txHash);
      console.log('‚úÖ ËÆ¢ÂçïÂèñÊ∂àÁ°ÆËÆ§ÂÆåÊàê');

      // Âà∑Êñ∞Êï∞ÊçÆ
      await web3Store.fetchAllData();

      return {
        success: true,
        transactionHash: txHash,
      };
    } catch (error: unknown) {
      console.error('‚ùå ÂèñÊ∂àËÆ¢ÂçïÂ§±Ë¥•:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [address, walletManager, web3Store]);

  return { mutateAsync: cancelOrder, isLoading };
}

/**
 * Hook to buy shares from a sell order
 */
export function useBuyShares() {
  const { address, walletManager } = useWallet();
  const web3Store = useWeb3Store();
  const [isLoading, setIsLoading] = useState(false);

  const buyShares = useCallback(async (params: { orderId: number }) => {
    if (!address || !walletManager) {
      throw new Error('Wallet not connected');
    }

    setIsLoading(true);
    try {
      console.log('üõí Ë¥≠‰π∞‰ªΩÈ¢ù...');
      console.log('üìã ËÆ¢ÂçïID:', params.orderId);

      // First get order details to calculate total price
      const orderData = await walletManager.readContract(
        CONTRACT_ADDRESSES.nftManager,
        ABI as unknown[],
        'sellOrders',
        [params.orderId]
      ) as [bigint, string, bigint, bigint, bigint, boolean];

      const [, , shares, pricePerShare, , active] = orderData;
      
      if (!active) {
        throw new Error('ËÆ¢ÂçïÂ∑≤Â§±Êïà');
      }

      const totalPrice = shares * pricePerShare;
      console.log('üí∞ ÊÄª‰ª∑Ê†º:', totalPrice.toString(), 'wei');

      // Approve USDT first
      console.log('üîê ÊéàÊùÉUSDT...');
      const approveTxHash = await walletManager.writeContract(
        CONTRACT_ADDRESSES.usdt,
        USDT_ABI as unknown[],
        'approve',
        [CONTRACT_ADDRESSES.nftManager, totalPrice],
        {
          gas: GAS_CONFIG.gasLimits.erc20Approve,
          gasPrice: 'auto', // ‰ΩøÁî®Ëá™Âä® Gas Price
        }
      );

      await walletManager.waitForTransaction(approveTxHash);
      console.log('‚úÖ USDTÊéàÊùÉÂÆåÊàê');

      // Buy shares
      const txHash = await walletManager.writeContract(
        CONTRACT_ADDRESSES.nftManager,
        ABI as unknown[],
        'buyShares',
        [params.orderId],
        {
          gas: GAS_CONFIG.gasLimits.buyShares,
          gasPrice: 'auto', // ‰ΩøÁî®Ëá™Âä® Gas Price
        }
      );

      console.log('‚úÖ Ë¥≠‰π∞‰ªΩÈ¢ù‰∫§ÊòìÂìàÂ∏å:', txHash);
      console.log('‚è≥ Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§...');

      const receipt = await walletManager.waitForTransaction(txHash);
      console.log('‚úÖ ‰ªΩÈ¢ùË¥≠‰π∞Á°ÆËÆ§ÂÆåÊàê');

      // Âà∑Êñ∞Êï∞ÊçÆ
      await web3Store.fetchAllData();

      return {
        success: true,
        transactionHash: txHash,
      };
    } catch (error: unknown) {
      console.error('‚ùå Ë¥≠‰π∞‰ªΩÈ¢ùÂ§±Ë¥•:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [address, walletManager, web3Store]);

  return { mutateAsync: buyShares, isLoading };
}

// Helper functions
function formatAddress(address: string): string {
  if (!address) return '';
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
}

function formatDate(timestamp: number): string {
  if (!timestamp) return '';
  const date = new Date(timestamp * 1000);
  return date.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
}
